视觉缺陷检测系统
---

# 现有视觉缺陷检测系统

## 典型系统

### HALCON

德国MVtec公司

支持C、C++、C#、Visual basic和Delphi等多种编程语言访问。其应用范围涵盖自动化检测、医学和生命科学、遥感探测、通讯和监控等众多领域。以其广泛的应用领域和强大的功能，被公认为具有最佳效能的机器视觉软件。

通用机器视觉软件，提供丰富的图像处理工具库。
包括无监督异常检测模块，支持深度学习和传统算法。
跨平台，支持多种编程语言（C++, Python 等）。

- 检测复杂、细微的缺陷：基于深度学习，不仅能检测局部缺陷，还能检测全局缺陷
- 训练简便：**只需要“合格”的图像就可以训练**，不需要可能包含人为缺陷的“不合格”图像
	- 不需要标注数据（不仅包含基于深度学习的方法，还包括基于规则的算法）
- 需要的图像少，速度快：运行速度 25 ms，每秒检测 40 次
- 可自动设置全天候运行

### DeepVision
![alt text](image-1.png)
1. 深度工业视觉识别系统：Galileo-X
	- 核心功能：建模、标注、训练、验证、检测、反馈、追加训练、报表
2. 在线检测系统：Galileo-T
    - 核心功能：数据统计、回查、分析、报表、辅助决策/标注过杀，漏检/反馈训练
    - 在线检测：专为产线上实时操作检测作业而设计的产品，服务于工业检测设备前端，直接面向设备操作者，为产线检测工作提供极大便利。
    - 功能与拓展性：检测模块、缺陷再过滤模块、数据样本反馈模块融合，能与Galileo-X或同类平台对接，以及市面上所有的运控系统、工控系统、设备完美对接。
    - 自由定制：根据不同产品制定独立的检测标准，检测方法和形式更加灵活。
3. 缺陷样本管理系统：Galileo-D
    - 核心功能：缺陷库分类、生成缺陷、生成新样本、数据调用、训练、测试
    - 专为辅助样本集采集与缺陷标注而设计，减少80%以上的人工操作，降低90%的样本采集时间，真正意义上实现了“无样本训练模型” 

## 现有系统一般检测流程

### 有监督目标检测（Maximo Visual Inspection）
1. 上传合格、不合格样本（即带有标签的数据集）
2. 自动数据增强（水平、垂直翻转以及旋转）以检测各种缺陷情况
3. 选择对象检测模型进行训练，同时自动**估算任务时间**、展示准确性分数
4. 部署模型检验，检测到缺陷时，自动标记缺陷位置并警报

### 无监督异常检测（HALCON）
1. 指定图像类别文件夹路径（**训练只需要合格图像**）
	- 也可以指定真值异常域（已知异常区域的标注数据），以优化模型
2. 设置参数，如图像大小、复杂度，对图像进行预处理，对齐
	- **处理不同缺陷大小**(预期缺陷越小图像越大)**和不同精度**(复杂度越大越精确)
	- 应用一个阈值来**缩小域并排除背景**
3. 设置参数，如误差和最大周期数、像素比率，训练模型
	- 图像变化很多但数量少，或图像很小，加大像素比率
	- 异常像素阈值在“验证”时计算，异常图像阈值在“测试”时计算
	- 训练(增强图像数据)至异常得分在一定范围内，同时展示训练进程
4. 应用模型后，得到异常图像和异常分数，计算阈值评估模型
	- 异常图像(阈值判断哪些像素异常)和异常分数（阈值判断是否异常）
	- 计算三种阈值：未错误分类的合格、不合格图像阈值，以及错误总数最少的阈值
	- 评估展示精度和召回率，以及混淆矩阵
5. 测试（预处理、预测、对图像和分数应用阈值）并显示结果（热图）
	- 逻辑异常和结构异常

## 现有系统分析

1. **检测精度有限**：对复杂背景或弱对比度缺陷的检测存在困难；小尺寸缺陷可能漏检或误检。
   - **集成多模态技术**：结合视觉、热成像、光谱分析等技术增强检测效果。
   - **优化深度学习模型**：采用轻量化模型（如MobileNet），提升实时性和资源效率。
2. **适应性差**：面对多种产品规格或材料，系统需要频繁重新训练或调整参数。
   - 设计适应多场景的通用模型架构。
   - 结合少样本学习（Few-shot Learning）或无监督学习
3. **数据依赖性强**：深度学习模型需要大量高质量标注数据，初期构建成本高。
   - 建立高质量、覆盖多种缺陷类型的大规模标注数据库。
   - 引入数据增强方法（如伪造缺陷生成）丰富训练样本。
4. **算法泛化能力不足**：在面对新的缺陷类型时，传统算法和部分机器学习方法效果不佳。
   - 引入在线学习能力，使系统能够自动适应新缺陷类型。
   - 提供缺陷成因分析和建议，帮助优化生产工艺。
5. **环境适应性不足**：在低光、强反光、震动等复杂环境下，检测效果不稳定。
   - 加强光照补偿与图像预处理技术。
   - 引入稳定装置或软件去抖动技术，减少环境干扰
6. **缺乏可解释性**：AI模型对缺陷判断缺乏透明性，难以明确原因。
   - 提供基于规则的辅助决策机制，增强模型可解释性。
   - 在检测报告中明确缺陷判断依据。

### 改进

1. 基于前景分割技术的高精度缺陷检测：项目重点研究如何将前景分割技术应用于缺陷检测中，通过背景建模和语义分割技术，区分检测对象与背景。
	- 当背景中出现较大噪声或者出现异常时，模型无法正确区分出所检测到的异常是否来源于目标物体，容易导致漏检，误检。
2. 基于多尺度检测的缺陷全覆盖检测：项目研究多尺度检测策略，并支持用户配置不同的缺陷大小范围，确保系统能够灵活适应不同领域的需求。
	- 当用户对所需要检测的异常大小有要求时，因为模型的单一尺度原因，无法做到覆盖全部大小的缺陷，容易产生漏检
3. 基于不同精度选项的不同运行功能：项目将研究如何提供精度选项，使用户根据不同需求选择不同的检测模式，适应从小批量高精度检测到大规模快速检测的需求。
	- 在一些情况中，用户或许对精度的要求远不及检测速度，往往需要通过降低检测精度的方法来追求低成本高速度

# 系统开发

## 需求分析

## 功能

### 基本功能

新建/修改归档 -> 采集样本 -> 新建模型、导入训练数据 -> 调参、训练模型 -> 配置模型、检测&展示

### 高级功能

1. 同时支持无监督异常检测和有监督目标检测
2. 开始时可指定真值异常域（已知异常区域的标注数据）
3. 开始时可**配置不同的缺陷大小范围**，支持多尺度异常检测。
4. 开始时**提供精度选项**，适应从小批量高精度检测到大规模快速检测的需求。
5. 预处理前**自动/手动设置参数**（图像尺寸和分辨率、背景排除阈值、缺陷区域提取范围、数据增强策略）
6. 预处理时**缩小域并排除背景**。
7. 预处理时**自动数据增强**（水平、垂直翻转以及旋转等）-> 缺陷样本管理
8. 预处理时自动识别并分类不同类型的异常、根据严重程度对缺陷进行分级
9. 训练前**自动/手动设置参数**（迭代次数/训练周期数、初始学习率、像素/图像异常阈值
10. 训练时**实时动态反馈**（训练时间估算、进度、准确率、损失曲线、召回率、精度、过/欠拟合分析等）
11. 训练后评估模型，并提供参数优化建议
12. 检测前**自动/手动设置参数**（缺陷大小范围、精度选项、异常类型选择）
13. 检测时**实时动态反馈**（检测时间估算、异常类别、异常位置热图、置信度分数和缺陷判断依据等）
15. 检测完提供缺陷成因分析和建议，帮助优化生产工艺。 

### 其它优化

1. 设计适应多场景的通用模型架构，适应多种产品规格或材料。
2. 加强光照补偿与图像预处理技术，引入软件去抖动技术，减少环境干扰。
3. 检测时自动进行增量训练与自我优化。
4. 通过历史数据分析，预测未来可能出现的异常模式，提前做出预警。



## patchcore分析

- 已实现功能：
   - 无监督异常检测
   - 指定真值异常域（通过提供ground truth mask进行评估）
   - 配置不同的缺陷大小范围，多尺度异常检测（通过参数 --resize 和 --imagesize）
   - 提供精度选项（例如通过调整 --anomaly_scorer_num_nn 和 --patchsize 参数）
   - 设置参数（例如图像尺寸、分辨率等，通过命令行参数）
   - 数据增强（例如水平、垂直翻转和旋转，通过数据预处理）
   - 实时动态反馈（通过在训练和检测过程中记录日志和生成图表）
- 需要自己实现的功能：
   - 有监督目标检测
   - 自动识别并分类不同类型的异常，根据严重程度对缺陷进行分级
   - 检测完提供缺陷成因分析和建议

### 参数分析

#### 通用参数设置
```python
@click.group(chain=True)
@click.argument("results_path", type=str)
@click.option("--gpu", type=int, default=[0], multiple=True, show_default=True)
@click.option("--seed", type=int, default=0, show_default=True)
@click.option("--log_group", type=str, default="group")
@click.option("--log_project", type=str, default="project")
@click.option("--save_segmentation_images", is_flag=True)
@click.option("--save_patchcore_model", is_flag=True)
```
- `results_path`: 结果存储路径
- `--gpu`: GPU编号，默认值为`0`
- `--seed`: 随机种子，默认值为`0`
- `--log_group`: 日志组名，默认值为`group`
- `--log_project`: 日志项目名，默认值为`project`
- `--save_segmentation_images`: 是否保存分割图像
- `--save_patchcore_model`: 是否保存PatchCore模型

#### PatchCore相关参数设置
```python
@main.command("patch_core")
# Pretraining-specific parameters.
@click.option("--backbone_names", "-b", type=str, multiple=True, default=[])
@click.option("--layers_to_extract_from", "-le", type=str, multiple=True, default=[])
# Parameters for Glue-code (to merge different parts of the pipeline.
@click.option("--pretrain_embed_dimension", type=int, default=1024)
@click.option("--target_embed_dimension", type=int, default=1024)
@click.option("--preprocessing", type=click.Choice(["mean", "conv"]), default="mean")
@click.option("--aggregation", type=click.Choice(["mean", "mlp"]), default="mean")
# Nearest-Neighbour Anomaly Scorer parameters.
@click.option("--anomaly_scorer_num_nn", type=int, default=5)
# Patch-parameters.
@click.option("--patchsize", type=int, default=3)
@click.option("--patchscore", type=str, default="max")
@click.option("--patchoverlap", type=float, default=0.0)
@click.option("--patchsize_aggregate", "-pa", type=int, multiple=True, default=[])
# NN on GPU.
@click.option("--faiss_on_gpu", is_flag=True)
@click.option("--faiss_num_workers", type=int, default=8)
```
- `--backbone_names`: 使用的backbone名称，backbone是用于提取特征的深度学习模型
- `--layers_to_extract_from`: 提取特征的层
- `--pretrain_embed_dimension`: 预训练嵌入维度，默认值为`1024`
- `--target_embed_dimension`: 目标嵌入维度，默认值为`1024`
- `--preprocessing`: 预处理方法，选择`mean`或`conv`，分别表示均值和卷积
- `--aggregation`: 聚合方法，选择`mean`或`mlp`，分别表示均值和多层感知器
- `--anomaly_scorer_num_nn`: 异常检测的最近邻数量，默认值为`5`
- `--patchsize`: patch大小，默认值为`3`，用于提取图像的局部特征
- `--patchscore`: patch评分方法，默认值为`max`
- `--patchoverlap`: patch重叠率，默认值为`0.0`
- `--patchsize_aggregate`: patch大小聚合
- `--faiss_on_gpu`: 是否在GPU上执行FAISS
- `--faiss_num_workers`: FAISS线程数，默认值为`8`

#### Sampler参数设置
```python
@main.command("sampler")
@click.argument("name", type=str)
@click.option("--percentage", "-p", type=float, default=0.1, show_default=True)
```
- `name`: 采样器名称
- `--percentage`: 采样百分比，默认值为`0.1`

#### 数据集参数设置
```python
@main.command("dataset")
@click.argument("name", type=str)
@click.argument("data_path", type=click.Path(exists=True, file_okay=False))
@click.option("--subdatasets", "-d", multiple=True, type=str, required=True)
@click.option("--train_val_split", type=float, default=1, show_default=True)
@click.option("--batch_size", default=2, type=int, show_default=True)
@click.option("--num_workers", default=8, type=int, show_default=True)
@click.option("--resize", default=256, type=int, show_default=True)
@click.option("--imagesize", default=224, type=int, show_default=True)
@click.option("--augment", is_flag=True)
```
- `name`: 数据集名称
- `data_path`: 数据集路径
- `--subdatasets`: 子数据集
- `--train_val_split`: 训练集和验证集的比例，默认值为`1`
- `--batch_size`: 批量大小，默认值为`2`
- `--num_workers`: 工作线程数，默认值为`8`
- `--resize`: 初始调整大小，默认值为`256`
- `--imagesize`: 最终图像大小，默认值为`224`
- `--augment`: 是否应用数据增强


### 已实现的功能
1. **支持无监督异常检测**：
   - **已实现**：`PatchCore` 是专门为无监督异常检测设计的，已经实现了通过深度学习模型（如 `ResNet`）提取特征，并基于这些特征计算异常评分的功能。无监督异常检测是 `PatchCore` 的核心功能之一。
   - **需要扩展**：如果你需要 **有监督目标检测**，则需要额外集成标注数据并进行相应的训练（`PatchCore` 目前主要专注于无监督异常检测）。

2. **支持真值异常域的输入（已知异常区域的标注数据）**：
   - **已实现**：`PatchCore` 默认是无监督的，但你可以通过使用已标注的异常区域（真值标签）来辅助训练和评估。这个部分可以通过定制化配置来实现，但它不是核心的自动化功能。

3. **支持多尺度异常检测**：
   - **已实现**：`PatchCore` 通过提取图像的多尺度特征并计算异常评分，支持多尺度异常检测。这是 `PatchCore` 的一部分，尤其是在模型训练时，通常会使用不同的图像尺寸来捕获不同大小的缺陷。

4. **精度选项**（适应小批量高精度到大规模快速检测的需求）：
   - **已实现**：`PatchCore` 支持调整批处理大小（batch size）和其他训练超参数来调整计算效率和精度。你可以在训练时调整精度、速度等方面的选项。

5. **自动/手动设置参数（图像尺寸、分辨率、背景排除阈值、缺陷区域提取范围、数据增强策略）**：
   - **部分已实现**：`PatchCore` 提供了图像尺寸和分辨率的设置选项，但背景排除阈值和缺陷区域提取范围等参数需要你在训练或检测阶段手动设置。
   - **需要扩展**：数据增强策略（如翻转、旋转等）需要额外配置。`PatchCore` 目前并没有提供全自动的数据增强策略，通常你需要自己手动实现或调整数据加载部分。

6. **预处理时缩小域并排除背景**：
   - **已实现**：在某些应用中，`PatchCore` 会自动调整图像的尺寸，并进行背景处理（通常是通过图像的特征提取来减少背景干扰）。

7. **自动数据增强**（水平、垂直翻转以及旋转等）：
   - **需要自己实现**：`PatchCore` 在默认的实现中没有集成自动的数据增强功能。你需要在数据加载或预处理阶段集成数据增强功能。

8. **自动识别并分类不同类型的异常、根据严重程度进行分级**：
   - **需要自己实现**：`PatchCore` 本身不提供异常分类和严重程度分级的功能。你需要自己在模型输出的基础上，设计异常类型识别和严重性分析。

### 需要实现的功能
9. **训练前自动/手动设置参数（迭代次数、训练周期数、初始学习率、像素/图像异常阈值）**：
   - **已实现**：`PatchCore` 提供了训练参数的手动设置选项，如迭代次数、学习率等，但完全自动化的设置可能需要根据具体需求进行调整。

10. **训练时实时动态反馈**（训练时间估算、进度、准确率、损失曲线、召回率、精度、过/欠拟合分析等）：
    - **已实现**：`PatchCore` 通过 TensorBoard 或类似工具可以提供训练过程中的实时反馈，如损失曲线、准确率、召回率等。

11. **训练后评估模型，并提供参数优化建议**：
    - **需要自己实现**：`PatchCore` 本身没有提供自动的参数优化建议功能。你可以通过性能评估（如精度、召回率等）后手动调整模型参数。

12. **检测前自动/手动设置参数（缺陷大小范围、精度选项、异常类型选择）**：
    - **部分已实现**：`PatchCore` 提供了一些参数设置选项，如图像大小、精度等，但异常类型选择和缺陷大小范围的设置需要自己配置。

13. **检测时实时动态反馈**（检测时间估算、异常类别、异常位置热图、置信度分数和缺陷判断依据等）：
    - **已实现**：`PatchCore` 提供了异常评分、异常区域热图等反馈内容。但异常类别和缺陷判断依据的详细分析需要根据模型输出进一步定制。

14. **检测后提供缺陷成因分析和建议，帮助优化生产工艺**：
    - **需要自己实现**：`PatchCore` 不提供缺陷成因分析或生产工艺优化的功能。此类功能需要额外的分析方法和业务逻辑来实现。

### 总结
在 `PatchCore` 项目中，以下功能已经实现或部分实现：
- 无监督异常检测
- 多尺度异常检测
- 参数手动设置和训练时的动态反馈
- 异常评分和热图的生成

但是，以下功能需要额外实现或扩展：
- 有监督目标检测
- 自动化数据增强和异常类型分类
- 完全自动的训练和检测参数优化建议
- 缺陷成因分析和生产工艺优化

你可以在现有的 `PatchCore` 框架基础上，针对特定需求进行功能扩展和定制化开发。

## 页面设计

|页面|复杂度|功能|
|-|-|-|
|归档配置页面|2|新建/修改归档|
|新建配方界面|5|接口接入、采集配方|
|训练模型页面|5|新建模型、读取样本、参数设置&描述、训练模型|
|配置模型页面|2|配置模型|
|运行检测页面|3|运行&检测效果展示|

基于您的需求，我们可以设计一个 Python + Qt 桌面应用程序的用户界面（UI）布局和交互流程。这个程序将结合 `PySide6` 进行界面开发，并实现与 `PatchCore` 视觉缺陷检测模型的集成。以下是对功能模块的详细设计，包括布局、交互流程和用户体验考虑。

### 1. UI布局设计

#### **主窗口 (Main Window)**

主窗口可以分为以下几个主要区域：

- **左侧功能导航栏 (Sidebar)**：
  - 各功能模块的快捷入口（例如：新建/修改归档、采集样本、训练模型、配置模型、检测&展示等）。
  - 采用树形结构或Tab形式，便于快速切换不同功能。

- **中间工作区 (Main Content Area)**：
  - 主要显示当前选中的功能模块，并展示相关的界面内容。

- **右侧状态栏 (Status Bar)**：
  - 显示实时反馈信息，如当前任务进度、检测结果、训练状态等。
  - 可显示日志、错误信息、警告、进度条等动态内容。

---

### 2. 界面布局与交互流程

以下为各个功能模块的具体界面设计及交互流程。

#### 2.1 **功能模块导航栏设计**
使用Tab导航或侧边栏导航来切换不同的功能模块。每个模块包含相关的子模块。

1. **新建/修改归档**：
   - 按钮：`新建归档`、`修改归档`
   - 弹窗：选择归档存储路径，输入项目名称，归档描述。
   
2. **采集样本**：
   - 按钮：`导入图像`、`选择文件夹`、`预览图像`
   - 预览功能：显示当前已选择的样本图像，用户可以选择多个图像进行批量处理。
   
3. **新建模型、导入训练数据**：
   - 按钮：`新建模型`、`导入数据`、`选择训练数据`。
   - 配置界面：选择数据集类型（无监督/有监督），设置训练数据路径。
   
4. **调参、训练模型**：
   - 按钮：`调参`、`开始训练`
   - 配置界面：提供调参选项（例如：迭代次数、学习率、图像分辨率等），并启动训练过程。
   - 显示实时训练反馈：显示训练进度、准确率、损失值、召回率等。

5. **配置模型、检测&展示**：
   - 按钮：`选择配置文件`、`检测图像`、`开始检测`
   - 配置界面：选择检测配置（缺陷大小范围、精度选项、异常类型等）。
   - 显示检测结果：包含缺陷位置、热图、置信度、检测进度等信息。

---

#### 2.2 **详细功能模块设计**

##### **1. 新建/修改归档**
- **操作界面**：用户可通过文件对话框新建或选择已存在的归档。
- **交互流程**：
  - 点击`新建归档`，弹出对话框填写项目名称、描述，并选择存储路径。
  - 点击`修改归档`，弹出选择已有归档的对话框。

##### **2. 采集样本**
- **操作界面**：提供按钮让用户导入单张图像或整个文件夹。
- **交互流程**：
  - 点击`导入图像`或`选择文件夹`，弹出文件选择框，用户可以选择图像或文件夹。
  - 图像预览区显示导入的图像，用户可以对图像进行旋转、翻转等预处理操作。

##### **3. 新建模型、导入训练数据**
- **操作界面**：用户可以选择训练数据类型（无监督或有监督），并导入数据。
- **交互流程**：
  - 点击`新建模型`，选择模型类型（PatchCore）及其他参数（如网络结构、初始配置等）。
  - 点击`导入训练数据`，用户可以选择数据集目录，支持批量导入并预处理。

##### **4. 调参、训练模型**
- **操作界面**：用户可以配置训练的参数（学习率、迭代次数、图像分辨率等）。
- **交互流程**：
  - 提供一个表单让用户输入训练参数（例如：迭代次数、学习率等）。
  - 点击`开始训练`后，显示实时的训练进度条、准确率、损失值等动态数据。
  - 提供中止训练的按钮，便于用户根据反馈调整训练策略。

##### **5. 配置模型、检测&展示**
- **操作界面**：用户选择检测配置（例如：缺陷大小、检测精度、异常类型）。
- **交互流程**：
  - 点击`选择配置文件`加载已有的配置文件，或自定义配置（如缺陷大小范围、精度要求等）。
  - 点击`开始检测`，展示检测进度，包括检测区域、异常热图、缺陷位置、置信度等。

---

#### 2.3 **高级功能设计**

1. **无监督与有监督检测切换**：
   - 在新建模型时，用户可以选择检测模式（无监督或有监督）。
   - 切换模式后，界面根据不同模式显示不同的操作选项。

2. **指定真值异常域（已知异常区域的标注数据）**：
   - 在有监督模式下，用户可以选择提供标注数据（异常区域的坐标或标签）。
   - 通过导入标注文件（如JSON、XML）来辅助训练。

3. **支持多尺度异常检测**：
   - 在配置模型时，提供选择缺陷大小范围的功能，支持缩放检测。

4. **精度选项与批量检测模式**：
   - 提供精度选项（高精度 vs 快速检测），并根据选择调整检测模型的灵敏度。

5. **自动/手动设置预处理参数**：
   - 提供预处理选项，允许用户手动调整参数（图像尺寸、背景排除阈值、数据增强策略等）。
   - 可选择自动数据增强或手动设置数据增强方式（如旋转、翻转等）。

6. **实时反馈（训练、检测）**：
   - 在训练时，实时更新训练过程，包括时间估算、进度、精度、召回率等。
   - 在检测时，展示检测区域热图、异常类别和检测结果置信度。

7. **缺陷成因分析与优化建议**：
   - 检测完成后，提供基于模型的缺陷分析报告，包括缺陷类型、位置、严重性分级，以及优化生产工艺的建议。

## 项目归档设计

### 1. **项目归档结构设计**

项目归档应该保存所有与视觉缺陷检测相关的文件和配置，包括但不限于：

- **项目元数据**：包括项目名称、描述、创建时间、版本等信息。
- **训练数据**：保存用户选择的训练数据集，包括图像、标签（如果是有监督学习）等。
- **训练配置**：保存模型训练的相关参数（如学习率、迭代次数等）。
- **模型文件**：保存训练好的模型权重（如 `patchcore_model.pth`）。
- **检测配置**：保存与检测相关的配置（如缺陷大小范围、精度选项等）。
- **检测结果**：保存检测过程中的所有数据，包括图像、检测结果、缺陷热图等。

#### 项目归档示例结构：
```
project_name/
│
├── metadata.json            # 项目元数据
├── train_data/              # 训练数据
│   ├── image1.jpg
│   ├── image2.jpg
│   └── ...
├── train_config.json        # 训练配置
├── model/                   # 保存训练好的模型
│   └── patchcore_model.pth  # 模型权重
├── detect_config.json       # 检测配置
└── detect_results/          # 检测结果
    ├── image1_result.json   # 检测结果数据
    ├── image1_heatmap.png   # 热图
    └── ...
```

### 2. **项目归档功能设计**

#### 2.1 **新建/修改归档**

- **新建归档**：当用户新建一个项目时，系统会提示用户输入项目名称和描述，并为该项目生成一个文件夹，所有相关的数据和配置文件都会保存在该文件夹中。
  
- **修改归档**：用户可以选择已有的项目进行修改或添加新的训练数据、训练模型等内容。

##### 操作步骤：
- 用户点击 `新建归档` 按钮，弹出文件夹选择对话框，让用户选择归档保存路径。
- 用户输入项目的名称、描述等元数据，并确认创建项目。
- 软件自动创建项目文件夹结构，并在其中保存元数据和其他数据。

#### 2.2 **归档文件的管理**

- **项目元数据**：所有项目信息（如名称、描述、创建时间等）可以保存在一个 JSON 文件中（`metadata.json`），这个文件可以方便地进行读取和编辑。
  
  ```json
  {
    "project_name": "Sample Defect Detection",
    "description": "A project to detect defects on PCB boards.",
    "created_at": "2024-12-18",
    "version": "1.0.0"
  }
  ```

- **数据保存路径**：用户导入训练数据时，数据可以被复制到项目文件夹下的 `train_data/` 目录中。这样可以保证归档中的数据和训练内容在同一目录下，便于管理和访问。

#### 2.3 **训练配置与模型保存**

- **训练配置**：保存训练的超参数，如学习率、批次大小、迭代次数等，可以使用一个 JSON 文件（如 `train_config.json`）来保存。

  ```json
  {
    "learning_rate": 0.001,
    "batch_size": 32,
    "epochs": 50,
    "image_size": [256, 256],
    "augmentation": {
      "flip": true,
      "rotate": true
    }
  }
  ```

- **模型保存**：训练后的模型（如 PatchCore 的权重文件 `patchcore_model.pth`）可以保存在项目的 `model/` 目录下。模型文件应具备版本控制机制，确保每次训练生成新的文件，并给文件命名时可以添加版本号或时间戳。

  - 示例：`patchcore_model_v1.pth`、`patchcore_model_v2.pth`。

#### 2.4 **检测结果保存**

- **检测结果**：每次检测结果可以保存为独立的文件，包含检测图像、缺陷位置、热图和其他相关信息。可以保存在 `detect_results/` 文件夹中。

  - 例如：`image1_result.json` 存储缺陷信息，`image1_heatmap.png` 存储热图。

  - 示例检测结果文件 (`image1_result.json`)：
  ```json
  {
    "image_name": "image1.jpg",
    "defects": [
      {
        "type": "crack",
        "confidence": 0.85,
        "bbox": [50, 100, 150, 200]
      },
      {
        "type": "scratch",
        "confidence": 0.92,
        "bbox": [200, 300, 250, 350]
      }
    ]
  }
  ```

#### 2.5 **用户交互界面**

- **项目管理面板**：在应用的左侧边栏，可以有一个项目管理面板，用户可以在其中创建、选择、删除或修改项目归档。
  
  - **新建归档**：点击按钮，弹出创建项目对话框，输入项目名称和描述，选择保存路径。
  - **加载项目**：点击项目名称，应用会加载相应的文件夹及其内容，显示项目信息、训练数据、模型、检测结果等。
  - **修改项目**：选择现有项目，进行数据更新、配置修改或重新训练等操作。

---

### 3. **项目归档的恢复与加载**

当用户打开一个已经保存的项目时，程序需要能够从归档文件中恢复项目的所有内容，包括训练数据、模型、检测结果等。

- **加载项目**：用户选择一个已存在的项目时，应用会读取该项目文件夹中的 `metadata.json` 文件来加载项目信息。
- **显示配置与结果**：根据项目中的配置文件和模型，加载并显示训练参数、检测结果、热图等。

### 4. **项目归档的版本控制**

随着项目的不断迭代和修改，建议实现一定的版本控制机制。每次模型训练或项目更新时，可以将版本号递增，或者使用时间戳命名保存的文件。比如：

- **模型文件版本**：`patchcore_model_v1.pth`、`patchcore_model_v2.pth`。
- **训练配置文件版本**：`train_config_v1.json`、`train_config_v2.json`。

### 5. **项目归档的导出和备份**

除了本地保存归档文件，还可以提供导出和备份功能，让用户能够将项目归档打包为一个压缩文件（如 `.zip`），便于备份或迁移。

- **导出功能**：提供一个按钮或菜单项，将当前项目及其所有文件（训练数据、模型、配置、结果等）打包为 `.zip` 文件，供用户备份或迁移。
- **备份**：定期备份项目归档，避免数据丢失。


## 具体开发流程

### 1. **开发 PatchCore 模型（服务器端）**
- **模型训练**：PatchCore 是基于深度学习的无监督异常检测方法，通常需要在服务器或云端进行训练。你需要确保你已经在服务器上完成了模型的训练，并保存了模型的权重文件。

  - 你可以使用框架如 PyTorch 或 TensorFlow 来实现 PatchCore，并完成训练。
  - 模型训练可以在服务器端定期进行更新，以便提升性能。

- **模型部署**：
  - 将训练好的 PatchCore 模型部署在服务器上，提供 API 接口供本地应用程序访问。
  - 可以选择使用 Flask、FastAPI 或 Django 来构建模型服务（API）。这样，你可以通过 HTTP 请求将图像上传到服务器，然后返回缺陷检测结果。

  **API 例子（FastAPI）**：
  ```python
  from fastapi import FastAPI, File, UploadFile
  import torch
  from pydantic import BaseModel

  app = FastAPI()

  # 加载训练好的 PatchCore 模型
  model = torch.load("patchcore_model.pth")

  @app.post("/detect")
  async def detect_defect(file: UploadFile = File(...)):
      # 处理文件，执行检测
      image = await file.read()
      result = model.detect(image)  # 需要根据模型定义修改
      return {"defect": result}
  ```

  - 启动 FastAPI 服务，监听一个端口（例如：`http://localhost:8000`）。
  - 你可以将这个服务部署到一个远程服务器或云平台（如 AWS、GCP、Azure）。

### 2. **开发 PySide6 桌面应用（本地开发）**
桌面应用部分你需要使用 `PySide6`（Qt 的 Python 绑定）来开发图形用户界面，并与部署在服务器上的 PatchCore 模型进行交互。

#### 2.1 **与服务器进行交互**
- **HTTP 请求与响应**：桌面应用会通过 HTTP 请求将图像发送到服务器，接收检测结果。
- 你可以使用 Python 的 `requests` 库来发送 HTTP 请求和处理响应。

  ```python
  import requests

  def detect_defect(image_path):
      url = "http://<server-ip>:8000/detect"
      with open(image_path, 'rb') as img_file:
          response = requests.post(url, files={'file': img_file})
      
      if response.status_code == 200:
          result = response.json()  # 处理返回的缺陷数据
          print(result)
      else:
          print(f"Error: {response.status_code}")
  ```

- **步骤**：
  1. 用户在桌面应用中选择一张图片。
  2. 应用通过 `requests` 将图片发送到服务器的 PatchCore 模型 API。
  3. 服务器返回检测结果，桌面应用处理并展示结果。

#### 2.2 **开发桌面应用界面**
- 使用 **PySide6**（Qt 的 Python 绑定）进行界面开发，PySide6 提供了强大的功能来设计桌面应用的 UI。
  
  - 设计界面时，你可以使用 Qt Designer 工具来帮助快速设计 GUI 界面，并将其导出为 `.ui` 文件，之后通过 `pyside6-uic` 转换为 Python 代码。

  - 在界面中，可以使用按钮让用户选择图像，显示实时的进度条、检测结果、热图等。

#### 2.3 **图像处理与结果展示**
- 在桌面应用中，图像加载、预处理、显示结果都可以通过 PySide6 中的 `QPixmap` 或 `QGraphicsView` 来实现。
- 当检测完成后，可以在界面上显示热图、置信度分数等信息。

---

### 3. **应用打包与发布**

#### 3.1 **打包为 Windows 可执行文件**
- 为了使最终用户能够轻松使用你的桌面应用，你需要将其打包成一个独立的可执行文件（`.exe`）。
- 使用 `PyInstaller` 或 `cx_Freeze` 来进行打包。

  **使用 PyInstaller**：
  - 安装 PyInstaller：
    ```bash
    pip install pyinstaller
    ```
  - 打包应用：
    ```bash
    pyinstaller --onefile --windowed your_app.py
    ```

    - `--onefile`：将所有文件打包为一个独立的 `.exe` 文件。
    - `--windowed`：避免在启动时弹出命令行窗口（适用于 GUI 应用）。

  - 打包完成后，`.exe` 文件将在 `dist/` 目录中生成，你可以将它分发给用户。

#### 3.2 **与服务器交互的注意事项**
- 确保服务器的 API 在用户使用时可访问。你可以使用本地服务器或者部署到云端（AWS、Azure、GCP 等）进行访问。
- 在打包前，测试网络通信部分，确保桌面应用能够与服务器进行顺利通信。

#### 3.3 **发布**
- 将生成的 `.exe` 文件与所需的依赖文件（如模型文件、库文件）打包在一起。
- 你可以通过压缩包、安装程序（如 Inno Setup、NSIS）或直接分发 `.exe` 文件来发布。
